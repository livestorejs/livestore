---
title: Events
sidebar:
  order: 4
---

import CommitEventSnippet from '../../_assets/code/reference/events/commit.ts?snippet'
import EventSchemaSnippet from '../../_assets/code/reference/events/livestore-schema.ts?snippet'
import { EventsVisualizer } from '../../../components/EventsVisualizer'

## Event definitions

There are two types of events:

- `synced`: Events that are synced across clients
- `clientOnly`: Events that are only processed locally on the client (but still synced across client sessions e.g. across browser tabs/windows)

An event definition consists of a unique name of the event and a schema for the event arguments. It's recommended to version event definitions to make it easier to evolve them over time.

Events will be synced across clients and materialized into state (i.e. SQLite tables) via [materializers](/reference/state/materializers).

### Example

<EventSchemaSnippet />

### Best Practices

- It's strongly recommended to use past-tense event names (e.g. `todoCreated`/`createdTodo` instead of `todoCreate`/`createTodo`) to indicate something already occurred.
- When generating IDs for events (e.g. for the todo in the example above), it's recommended to use a globally unique ID generator (e.g. UUID, nanoid, etc.) to avoid conflicts. For convenience, `@livestore/livestore` re-exports the `nanoid` function.
- TODO: write down more best practices
- TODO: mention AI linting (either manually or via a CI step)
  - core idea: feed list of best practices to AI and check if events adhere to them + get suggestions if not
- It's recommended to avoid `DELETE` events and instead use soft-deletes (e.g. add a `deleted` date/boolean column with a default value of `null`). This helps avoid some common concurrency issues.

### Nodes in the LiveStore system

#### Client Session
- SyncState in-memory for pending events only
- Materialized state that matches the schema (SQLite database)

#### Client leader
- SQLite dbState - mirrors schema so leader can materialize events and handle rollbacks
- SQLite dbEventLog - stores the durable event log and tracks global sequence of events which the backend has acknowledged

#### Sync backend
- Any storage solution that supports pushing and pulling events. Events are never deleted only appended.

### Event commit (happy path)

1. Client commits an event
    - Merges event into local SyncState with state pending
    - Pushes event to leader thread

<EventsVisualizer title='Client Session' events={["A:e1{todoCreated}", "A:e1.1", "A:e2r1", "A:e3'"]} />
<EventsVisualizer title='Client Leader' events={["A:e1", "A:e2'"]} />
<EventsVisualizer title='Sync Backend' events={["A:e1", "B:e2"]} />

2. Leader thread persists the event
    - Materializes event
    - Writes row to EventLog table

3. Leader thread emits signal back to subscribed clients
    - On receipt client merges new event into SyncState
    - Event in client goes from pending to confirmed
    - Client syncState and leader head now at same location

4. Leader thread pushes event to backend
    - Event still marked as pending in leader thread

6. Backend pulls event from leader thread
    - Notifies leader thread of receipt
    - Leader thread marks event as confirmed
    - Backend head advances
    - Event confirmed on all levels and heads at same location

### Event rebase (conflict resolution)

This can happen in on client and leader level

1. Leader thread detects incoming events that conflict with the clients pending chain
    - Local events are compared to upstream events to find point of divergence

2. Client rolls back changes until divergence point
    - Each event has a SQLite changeset which is used to revert the applied changes in reverse order
    - Database state is now restored to point where events diverged

3. Client applies upstream canonical events
    - Previous events in syncstate are replaced by new events
    - Original pending events are stored so their changesets can be cleaned up (rollbackEvents)

4. Client replays its own pending events on top of new head
    - Stored original events (rollbackEvents) keep their original payload but their sequence number gets updated to follow upstream head
    - Each newly numbered event is re-appplied (materialized) to store database

5. Leader and backend stay in sync
    - Leader applies same rollback/replay cycle if the backend event forces the rebase first
    - After replay both leader head and client syncstate head are aligned

### What happens to an event during rebase?

1. Before conflict
    - Client pending list: e42 (rename todo)
    - Leader `eventlog`: … e41, e42
    - Backend has not seen e42 yet

2. Upstream sends a rebase (Step 1)
    - Leader receives canonical history that replaces e42 with a different event

3. Rollback (Step 2)
    - Leader runs `rollback` and deletes the old e42 row from `eventlog`
    - Client `SyncState.pending` drops e42

4. Apply upstream events (Step 3)
    - Leader inserts the canonical e42 from upstream
    - Client applies the same canonical e42

5. Replay local work (Step 4)
    - Client rename event is re-enqueued as e43 and materialized
    - Client `SyncState.pending` now holds e43; leader `eventlog` shows … e41, e42 (canonical), e43

Result: the original e42 is gone; the sequence jumps from the upstream e42 straight to the rebased local e43.

A gap in the leader event log (e1, e3) is never possible unless an upstream rebase deletes a row and never replaces it. Because the backend is sync only this should never happen.

### Unknown events

Older clients might receive events that were introduced in newer app versions. Configure the behaviour centrally via `unknownEventHandling` when constructing the schema:

```ts
const schema = makeSchema({
  events,
  state,
  unknownEventHandling: {
    strategy: 'callback',
    onUnknownEvent: (event, error) => {
      console.warn('LiveStore saw an unknown event', { event, reason: error.reason })
    },
  },
})
```

Pick `'warn'` (default) to log every occurrence, `'ignore'` to silently drop new events until the client updates, `'fail'` to halt immediately, or `'callback'` to delegate to custom logging/telemetry while continuing to process the log.

### Schema evolution \{#schema-evolution\}

- Event definitions can't be removed after they were added to your app.
- Event schema definitions can be evolved as long as the changes are forward-compatible.
  - That means data encoded with the old schema can be decoded with the new schema.
  - In practice, this means ...
    - for structs ...
      - you can add new fields if they have default values or are optional
      - you can remove fields

## Commiting events

<CommitEventSnippet />

## Eventlog

The history of all events that have been committed is stored forms the "eventlog". It is persisted in the client as well as in the sync backend.

Example `eventlog.db`:

![](https://share.cleanshot.com/R6ny879w+)
