name: Set up environment
description: Set up the environment with Nix and direnv.
runs:
  using: composite
  steps:
    - name: Install Determinate Nix
      uses: DeterminateSystems/determinate-nix-action@v3

    - name: Use FlakeHub Cache for Nix binaries
      # flakehub-cache-action supersedes and is faster than magic-nix-cache-action.
      uses: DeterminateSystems/flakehub-cache-action@main

    - name: Get pnpm store directory
      # This is needed because pnpm's store path is not fixed and can vary based on the environment.
      id: pnpm-store
      shell: bash
      # We use `nix develop --command` because the `pnpm` CLI is installed via Nix.
      run: echo "DIR_PATH=$(nix develop ./nix --command pnpm store path --silent)" >> $GITHUB_OUTPUT

    - name: Cache pnpm store
      uses: actions/cache@v4
      with:
       # We only should cache the pnpm store, and not the node_modules directory. Caching it duplicates effort since the
       # pnpm store already covers the package contents, and leads to issues with package resolution.
       path: ${{ steps.pnpm-store.outputs.DIR_PATH }}
       key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
       restore-keys: ${{ runner.os }}-pnpm-store-

    - name: Cache direnv setup
      uses: actions/cache@v4
      with:
        path: |
          .direnv
        key: direnv-${{ runner.os }}-${{ hashFiles('.envrc', 'nix/**', 'flake.nix', 'flake.lock', 'scripts/standalone/setup.ts') }}-${{ github.sha }}
        restore-keys: |
          direnv-${{ runner.os }}-${{ hashFiles('.envrc', 'nix/**', 'flake.nix', 'flake.lock', 'scripts/standalone/setup.ts') }}-

    - name: Install direnv
      shell: bash
      run: nix profile add nixpkgs#direnv

    - name: Load environment with direnv
      # See https://github.com/direnv/direnv/wiki/GitHubActions for more details
      shell: bash
      run: |
        direnv allow
        direnv exec . sh -c 'echo $PATH' > "$GITHUB_PATH"
        direnv export gha >> "$GITHUB_ENV"

    - name: Collect and log runner machine info
      shell: bash
      run: |
        echo "::group::Runner machine info"
        set -euo pipefail

        uname -a || true
        echo "Date (UTC): $(date -u +"%Y-%m-%dT%H:%M:%SZ")"

        # CPU
        CPU_COUNT=$(nproc --all 2>/dev/null || getconf _NPROCESSORS_ONLN || echo "")
        CPU_MODEL=$(lscpu 2>/dev/null | awk -F: '/Model name/ {sub(/^[ \t]+/, "", $2); print $2; exit}')
        if [ -z "${CPU_MODEL:-}" ]; then
          CPU_MODEL=$(grep -m1 'model name' /proc/cpuinfo 2>/dev/null | cut -d: -f2- | sed 's/^ *//')
        fi
        CPU_MHZ=$(lscpu 2>/dev/null | awk -F: '/CPU MHz/ {sub(/^[ \t]+/, "", $2); print $2; exit}')
        CPU_MAX_MHZ=$(lscpu 2>/dev/null | awk -F: '/CPU max MHz/ {sub(/^[ \t]+/, "", $2); print $2; exit}')

        # Memory
        MEM_TOTAL_KB=$(awk '/MemTotal/ {print $2}' /proc/meminfo 2>/dev/null || echo "")
        MEM_AVAILABLE_KB=$(awk '/MemAvailable/ {print $2}' /proc/meminfo 2>/dev/null || echo "")

        # Load averages
        if [ -r /proc/loadavg ]; then
          read LOAD1 LOAD5 LOAD15 _ < /proc/loadavg
        else
          LOAD1=""; LOAD5=""; LOAD15="";
        fi
        if [ -n "${CPU_COUNT}" ] && [ -n "${LOAD1}" ]; then
          LOAD1_PER_CORE=$(awk -v l="${LOAD1}" -v c="${CPU_COUNT}" 'BEGIN { if (c+0>0) printf "%.2f", l/c }')
        else
          LOAD1_PER_CORE=""
        fi

        # Human-friendly summary
        echo "OS: $(uname -s) $(uname -r) $(uname -m)"
        echo "CPU: ${CPU_MODEL:-unknown} (cores: ${CPU_COUNT:-unknown})"
        if [ -n "${CPU_MAX_MHZ}" ]; then
          echo "Frequency: ${CPU_MHZ:-n/a} MHz (max ${CPU_MAX_MHZ} MHz)"
        elif [ -n "${CPU_MHZ}" ]; then
          echo "Frequency: ${CPU_MHZ} MHz"
        fi
        if [ -n "${MEM_TOTAL_KB}" ]; then
          MEM_TOTAL_GB=$(awk -v k="${MEM_TOTAL_KB}" 'BEGIN { printf "%.2f", k/1024/1024 }')
          MEM_AVAIL_GB=$(awk -v k="${MEM_AVAILABLE_KB}" 'BEGIN { printf "%.2f", k/1024/1024 }')
          echo "Memory: total ${MEM_TOTAL_GB} GB, available ${MEM_AVAIL_GB} GB"
        fi
        if [ -n "${LOAD1}" ]; then
          echo "Load avg: 1=${LOAD1} 5=${LOAD5} 15=${LOAD15} (1m per-core=${LOAD1_PER_CORE})"
        fi

        # Node’s view (optional; won’t fail the step)
        node -e "const os=require('os'); const c=os.cpus(); console.log('Node view:', JSON.stringify({os:{type:os.type(),platform:os.platform(),release:os.release(),arch:os.arch()}, cpu:{count:c?.length, model:c?.[0]?.model, speedMHz:c?.[0]?.speed}, loadAvg:os.loadavg(), mem:{total:os.totalmem(), free:os.freemem()}}, null, 2));" || true

        echo "::endgroup::"

        # Export to env for downstream steps
        {
          [ -n "${CPU_COUNT}" ] && echo "RUNNER_CPU_COUNT=${CPU_COUNT}";
          [ -n "${CPU_MODEL}" ] && echo "RUNNER_CPU_MODEL=${CPU_MODEL}";
          [ -n "${CPU_MHZ}" ] && echo "RUNNER_CPU_MHZ=${CPU_MHZ}";
          [ -n "${CPU_MAX_MHZ}" ] && echo "RUNNER_CPU_MAX_MHZ=${CPU_MAX_MHZ}";
          [ -n "${MEM_TOTAL_KB}" ] && echo "RUNNER_MEM_TOTAL_KB=${MEM_TOTAL_KB}";
          [ -n "${MEM_AVAILABLE_KB}" ] && echo "RUNNER_MEM_AVAILABLE_KB=${MEM_AVAILABLE_KB}";
          [ -n "${LOAD1}" ] && echo "RUNNER_LOAD_1=${LOAD1}";
          [ -n "${LOAD5}" ] && echo "RUNNER_LOAD_5=${LOAD5}";
          [ -n "${LOAD15}" ] && echo "RUNNER_LOAD_15=${LOAD15}";
          [ -n "${LOAD1_PER_CORE}" ] && echo "RUNNER_LOAD1_PER_CORE=${LOAD1_PER_CORE}";
        } >> "$GITHUB_ENV"
